class name with Pascal case{

	Member variables are private and camel case 
	
	default constructor as public 
	parameterised contructor as public

	setters as public and camel case 
	getters as public and camel case 
	
	toString as public and camel case 
	Behaviours as public and camel case 

}


git init

git add .

git status

git commit -m "First commit"

git status


git remote add origin ......[SSL URL ]


git push origin master --force









https://www.eclipse.org/downloads/
    
    
    
    

https://github.com/sbmadake/githublearning


Key GitHub features include:
Issues
Discussions
Pull requests
Notifications
Labels
Actions
Forks
Projects

Git is a distributed version-control system (DVCS) that allows multiple developers or other contributors to work on a project. It provides a way to work with one or more local branches and push them to a remote repository. Git is responsible for everything GitHub-related that happens locally on your computer. Key Git features include:
It's installed and used on your local machine
Handles version control
Supports branching
To learn more about Git, see Using Git.
GitHub is a cloud platform that uses Git as its core technology. It simplifies the process of collaborating on projects and provides a website, command-line tools, and overall flow that allows developers and users to work together. GitHub acts as the "remote repository" mentioned previously in the Git section.





Git was developed in 2005 by Linus Torvalds as open source software for tracking changes in a distributed version control system.
Git is open source because its source code is made freely available for anyone to modify and use, aside from its creator. Open-source projects are built and maintained collectively by different developers in different locations.
Git track changes via a distributed version control system. This means that Git can track the state of different versions of your projects while you're developing them. It is distributed because you can access your code files from another computer – and so can other developers.
When you're building an open source project, you'll need a way to document or track your code. This helps make your work organized, and lets you keep track of the changes you've made. This is what Git lets you do.
But you also need a place to host your code – which makes controlling each version of your project easier and faster. This is where GitHub comes in.
GitHub is a "hub" (a place or platform) where Git users build software together. GitHub is also an hosting provider and version control platform you can use to collaborate on open source projects and share files. When you're using GitHub, you're working with Git beneath the hood.











types of lang:
1.obj based lang :support two major pillor (abstraction,encapsulation). ex. c++
2.obj oriented lang :support 4 major pillor ex. java ,python ,c++
3.pure object oriented: lang support 4 major pillor with 3 minor pillor. ex. erlang ,eliff

major pillors of oop:
  1.abstraction 
  2.encapsulation
  3.inheritance
  4.polymorphism
minor pillor:
1.type casting
2.concurrency
3.persistance





   
                    
object is an entity which hAS well defined structure and behaviour
 object can be tangible or conceptual.

chas of obj:
1.state -current value of attribute
2.behaviour -how its acts and react in term of state change.
3.identity -uniqueness
4.responsibility -role played by object in system

27/09/23
 
https://quizizz.com/join?gc=223260
    
    
    
    
    
    

Lines or arrows between classes indicate relationships
Association
A relationship between instances of two classes, where one class must know about the other to do its work, e.g. client communicates to server
indicated by a straight line or arrow
Aggregation 
An association where one class belongs to a collection, e.g. instructor part of Faculty
Indicated by an empty diamond on the side of the collection
Composition
Strong form of Aggregation 
Lifetime control; components cannot exist without the aggregate
Indicated by a solid diamond on the side of the collection
Inheritance
An inheritance link indicating one class a superclass relationship, e.g. bird is part of mammal
Indicated by triangle pointing to superclass









A <<includes>> B 
Somewhere through use case A, use case B is called. When B finishes, A carries on from where it left off.
A <<extends>> B 
All the steps from use case A are performed during the execution of use case B, at the extension point which is specified within B.
A <<precedes>> B 
Use case A must take place in its entirety before use case B even begins.
A <<invokes>> B 
Use case B happens during the lifespan of use case A. 











Name: Purchase ticket

Participating actor: Passenger

Entry condition: 
Passenger standing in front of ticket distributor.
Passenger has sufficient money to purchase ticket.

Exit condition:
Passenger has ticket.


Event flow:
1. Passenger selects the number of zones to be traveled.
2. Distributor displays the amount due.
3. Passenger inserts money, of at least the amount due.
4. Distributor returns change.
5. Distributor issues ticket.






A use case represents a class of functionality provided by the system as an event flow.

A use case consists of:
Unique name
Participating actors
Entry conditions
Flow of events
Exit conditions
Special requirements




An actor models an external entity which communicates with the system:
User
External system
Physical environment
An actor has a unique name and an optional description.
Examples:
Passenger: A person in the train
GPS satellite: Provides the system with  GPS coordinates



Used during requirements elicitation to represent external behavior

Actors represent roles, that is, a type of user of the system
Use cases represent a sequence of interaction for a  type of functionality; summary of scenarios
The use case model is  the set of all use cases. It is a complete description of the functionality of the  system and its environment





https://www.visual-paradigm.com/features/uml-tool/
    
    
    
    
 


STATIC
  Use case diagram
  Class Diagram
Dynamic
 Object Diagram
 State Diagram
 Activity Diagram
 Sequence Diagram
 collaboration Diagram
   
Implementation 

  Component Diagram
  Deployment Diagram





Use Case Diagrams
Class Diagrams
Package Diagrams
Interaction Diagrams
Sequence
Collaboration
Activity Diagrams
State Transition Diagrams
Deployment Diagrams


A model is an abstraction describing a subset of a system
A view depicts selected aspects of a model
A notation is a set of graphical or textual rules for depicting views
Views and models of a single system may overlap each other

Examples:
System: Aircraft
Models: Flight simulator, scale model
Views: All blueprints, electrical wiring, fuel system

    
    

Inundated with methodologies in early 90’s
Booch, Jacobson, Yourden, Rumbaugh
Booch, Jacobson merged methods 1994
Rumbaugh joined 1995
1997 UML 1.1 from OMG includes input from others, e.g. Yourden
UML v2.0 current version



Open Standard, Graphical notation for
Specifying, visualizing, constructing, and documenting software systems
Language can be used from general initial design to very specific detailed design across the entire software development lifecycle
Increase understanding/communication of product to customers and developers
Support for diverse application areas
Support for UML in many software packages today (e.g. Rational, plugins for popular IDE’s like NetBeans, Eclipse)
Based upon experience and needs of the user community




Unified Modeling Language
OMG Standard, Object Management Group
Based on work from Booch, Rumbaugh, Jacobson
UML is a modeling language to express and design documents, software
Particularly useful for OO design
Not a process, but some have been proposed using UML
Independent of implementation language


******************* 26/9/2023 UML ********




The four values of Agile are the pillars of Agile methodology. From those values, the team developed 12 principles. 
If the four values of Agile are the weight-bearing pillars of a house, then these 12 principles are the rooms you can build within that house. These principles can be easily adapted to fit the needs of your team. 
The 12 principles used in Agile methodology are:
Satisfy customers through early, continuous improvement and delivery.When customers receive new updates regularly, they're more likely to see the changes they want within the product. This leads to happier, more satisfied customers—and more recurring revenue.
Welcome changing requirements, even late in the project. The Agile framework is all about adaptability. In iterative processes like Agile, being inflexible causes more harm than good. 
Deliver value frequently. Similar to principle #1, delivering value to your customers or stakeholders frequently makes it less likely for them to churn. 
Break the silos of your projects. Collaboration is key in the Agile framework. The goal is for people to break out of their own individual projects and collaborate together more frequently. 
Build projects around motivated individuals. Agile works best when teams are committed and actively working to achieve a goal. 
The most effective way to communicate is face-to-face. If you’re working on a distributed team, spend time communicating in ways that involve face-to-face communication like Zoom calls. 
Working software is the primary measure of progress. The most important thing that teams should strive for with the Agile framework is the product. The goal here is to prioritize functional software over everything else.
Maintain a sustainable working pace. Some aspects of Agile can be fast-paced, but it shouldn't be so fast that team members burn out. The goal is to maintain sustainability throughout the project.
Continuous excellence enhances agility. If the team develops excellent code in one sprint, they can continue to build off of it the next. Continually creating great work allows teams to move faster in the future. 
Simplicity is essential. Sometimes the simplest solution is the best solution. Agile aims to not overcomplicate things and find simple answers to complex problems. 
Self-organizing teams generate the most value. Similar to principle #5, proactive teams become valuable assets to the company as they strive to deliver value.
Regularly reflect and adjust your way of work to boost effectiveness. Retrospective meetings are a common Agile practice. It's a dedicated time for teams to look back and reflect on their performance and adapt their behaviors for the future.









The Agile software development life cycle helps you break down each project you take on into six simple stages:
Concept: Define the project scope and priorities
Inception: Build the Agile team according to project requirements 
Iteration: Create code factoring in customer feedback 
Release: Test the code and troubleshoot any issues
Maintenance: Provide ongoing tech support to ensure the product remains serviceable
Retirement: The end of the product lifespan, which often coincides with the beginning of a new one


    
    
    
    


Agile project management is not a singular framework but an umbrella term that includes a wide range of methodologies, 
including Scrum, Kanban, Extreme Programming (XP), and the Adaptive Project Framework (APF).
Scrum: It is ideal for projects with rapidly changing requirements, using short sprints.
Kanban: It visualizes project progress and is great for tasks requiring steady output.Lean: 
It streamlines processes, eliminating waste for customer value.Extreme Programming (XP): 
It enhances software quality and responsiveness to customer satisfaction.Adaptive Project Framework (APF):
 Works well for projects with unclear details, as it adapts to constantly evolving client needs.







Agile is one of the most popular approaches to project management because it is flexible, it is adaptable to changes and it encourages customer feedback.
Many teams embrace the Agile approach for the following reasons:
Rapid progress: By effectively reducing the time it takes to complete various stages of a project,
 teams can elicit feedback in real time and produce working prototypes or demos throughout the process
Customer and stakeholder alignment: Through focusing on customer concerns and stakeholder feedback, the Agile team is well positioned to produce results that satisfy the right people
Continuous improvement: As an iterative approach, Agile project management allows teams to chip away at tasks until they reach the best end result



DROP TRIGGER
In MySQL Trigger can also be drop. When Trigger drops, then it is removed from the database.

Syntax
Drop Trigger[ IF EXISTS ] Trigger_name;  
Parameter:
Trigger_name: Name of the Trigger to be dropped

Example 1
drop Trigger student_update; 






CREATE TRIGGER 'student_delete' AFTER DELETE ON 'student' FOR EACH ROW DELETE FROM student2 WHERE student.id=student1.id;






In MySQL, AFTER/BEFORE DELETE trigger can also be created. AFTER/BEFORE DELETE trigger means trigger will invoke after/before the record is deleted.

Syntax
CREATE TRIGGER trigger_name  
    AFTER/BEFORE DELETE  
         ON table_name FOR EACH ROW  
         BEGIN  
        --variable declarations  
        --trigger code  
        END;  
Parameter:
trigger_name: name of the trigger to be created.

AFTER/BEFORE DELETE: It points the trigger after/before delete query is executed.

table_name: name of the table in which a trigger is created.

    
    
    
    
    









CREATE TABLE employees_audit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    employeeNumber INT NOT NULL,
    lastname VARCHAR(50) NOT NULL,
    changedat DATETIME DEFAULT NULL,
    action VARCHAR(50) DEFAULT NULL
);


DELIMITER $$
CREATE TRIGGER before_employee_update 
    BEFORE UPDATE ON employees
    FOR EACH ROW 
BEGIN
    INSERT INTO employees_audit
    SET action = 'update',
     employeeNumber = OLD.employeeNumber,
        lastname = OLD.lastname,
        changedat = NOW(); 
END$$
DELIMITER ;








CREATE TABLE test1(a1 INT);
CREATE TABLE test2(a2 INT);
CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE test4(
  a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  b4 INT DEFAULT 0
);

delimiter |

CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW
  BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END;
|

delimiter ;

INSERT INTO test3 (a3) VALUES
  (NULL), (NULL), (NULL), (NULL), (NULL),
  (NULL), (NULL), (NULL), (NULL), (NULL);

INSERT INTO test4 (a4) VALUES
  (0), (0), (0), (0), (0), (0), (0), (0), (0), (0);

    
    
    
    
    mysql> INSERT INTO test1 VALUES 
       (1), (3), (1), (7), (1), (8), (4), (4);
Query OK, 8 rows affected (0.01 sec)
Records: 8  Duplicates: 0  Warnings: 0

    
    
    

SET @sum=0;


insert into accounts values(1,10000.23);
insert into accounts values(2,20000);

select @sum;

CREATE TRIGGER trg_insert BEFORE INSERT on accounts
for EACH ROW
SET @sum=@sum+NEW.amount;




CREATE TABLE accounts(account_nun int,amount decimal(10,2));












------Creating Stored Procedures in MySQL------



--Make sure you have version 5 of MySQL:

SELECT VERSION();

+-----------+
| VERSION() |
+-----------+
| 5.0.15-nt |
+-----------+
1 row in set (0.00 sec)



--First pick a database to use (a procedure, like a table, is associated with
--a single database.) For these examples, I will use a database that is populated
--with the tables from HW 2:

USE ozaidan_hw2;



--Next, change the delimiter, because we will use the semicolon WITHIN the
--procedure declarations, and therefore it cannot be the delimiter anymore:

DELIMITER //



--OK, let's get started. Creating procedures is straightforward:

CREATE PROCEDURE myFirstProc()
  SELECT 'Hello World!' AS Output;
//

Query OK, 0 rows affected (0.00 sec)

--Whenever you create a procedure (successfully) you should get a 'Query OK' message.

--Calling a procedure is also straightforward:

CALL myFirstProc() //

+--------------+
| Output       |
+--------------+
| Hello World! |
+--------------+
1 row in set (0.00 sec)

--By the way, procedure names are NOT case sensitive:

CALL myfirstproc() //

+--------------+
| Output       |
+--------------+
| Hello World! |
+--------------+
1 row in set (0.00 sec)



--Another example:

CREATE PROCEDURE ListStudents()
  SELECT *
  FROM Student;
//

CALL ListStudents() //

+-------+----------+---------+------+------+-------+---------+-----------+
| StuID | LName    | Fname   | Age  | Sex  | Major | Advisor | city_code |
+-------+----------+---------+------+------+-------+---------+-----------+
|  1001 | Smith    | Linda   |   18 | F    |   600 |    1121 | BAL       |
|  1002 | Kim      | Tracy   |   19 | F    |   600 |    7712 | HKG       |
.
.
.
|  1034 | Epp      | Eric    |   18 | M    |    50 |    5718 | BOS       |
|  1035 | Schmidt  | Sarah   |   26 | F    |    50 |    5718 | WAS       |
+-------+----------+---------+------+------+-------+---------+-----------+
34 rows in set (0.00 sec)



--Say we only want student ID's and names. To update a procedure, we must
--first DROP it:

DROP PROCEDURE IF EXISTS ListStudents //

Query OK, 0 rows affected (0.00 sec)

--Again, whenever you drop a procedure, you should get a 'Query OK' message.
--From now on, we will always use "DROP PROCEDURE IF EXISTS procName" as
--a standard practice before declaring procedures:

DROP PROCEDURE IF EXISTS ListStudents //
CREATE PROCEDURE ListStudents()
  SELECT StuID, LName, FName
  FROM Student;
//

CALL ListStudents() //

+-------+----------+---------+
| StuID | LName    | FName   |
+-------+----------+---------+
|  1001 | Smith    | Linda   |
|  1002 | Kim      | Tracy   |
.
.
.
|  1034 | Epp      | Eric    |
|  1035 | Schmidt  | Sarah   |
+-------+----------+---------+
34 rows in set (0.00 sec)



--OK, let's use some parameters:

DROP PROCEDURE IF EXISTS sayHello //
CREATE PROCEDURE sayHello(IN name VARCHAR(20))
  SELECT CONCAT('Hello ', name, '!') AS Greeting;
//

--The 'IN' keyword tells MySQL that is should be expecting an input value for
--the parameter......hunh? Why would a parameter NOT have an input value? You will
--see in a little bit. First, let's see if sayHello works:

CALL sayHello('Omar') //

+-------------+
| Greeting    |
+-------------+
| Hello Omar! |
+-------------+
1 row in set (0.00 sec)



--Another example:

DROP PROCEDURE IF EXISTS saySomething //
CREATE PROCEDURE saySomething(IN phrase VARCHAR(20), IN name VARCHAR(20))
  SELECT CONCAT(phrase, ' ', name, '!') AS Output;
//

CALL saySomething('Go','Blue Jays') //
CALL saySomething('Do','my homework') //

+---------------+
| Output        |
+---------------+
| Go Blue Jays! |
+---------------+
1 row in set (0.00 sec)

+-----------------+
| Output          |
+-----------------+
| Do my homework! |
+-----------------+
1 row in set (0.00 sec)



--and another one:

DROP PROCEDURE IF EXISTS FindStudent //
CREATE PROCEDURE FindStudent(IN id INT)
  SELECT StuID, CONCAT(FName, ' ', LName) AS 'Student Name'
  FROM Student
  WHERE StuID = id;
//

CALL FindStudent(1001) //

+-------+--------------+
| StuID | Student Name |
+-------+--------------+
|  1001 | Linda Smith  |
+-------+--------------+
1 row in set (0.00 sec)



--and yet another:

DROP PROCEDURE IF EXISTS calculate //
CREATE PROCEDURE calculate(IN x INT, IN y INT, OUT sum INT, OUT product INT)
  SET sum = x + y;
  SET product = x * y;
//

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual ...

--Well, that wasn't good. The reason is, we must use BEGIN/END if we have
--a compound statement:

DROP PROCEDURE IF EXISTS calculate //
CREATE PROCEDURE calculate(IN x INT, IN y INT, OUT sum INT, OUT product INT)
BEGIN
  SET sum = x + y;
  SET product = x * y;
END;
//

--Did you notice the 'OUT' keyword for sum and product? This tells MySQL that those
--two parameters are not 'input' parameters but are 'output' parameters instead.
--Now, when calling the procedure, we need to provide four parameters: two input
--values, and two MySQL *variables* where the results will be stored:

CALL calculate(4,5,@s,@p) //

Query OK, 0 rows affected (0.00 sec)

--Here, @s and @p are MySQL variables. Notice that they start with @, although
--procedure *parameters* do not start with @

SELECT @s //
SELECT @p //

+------+
| @s   |
+------+
| 9    |
+------+
1 row in set (0.00 sec)

+------+
| @p   |
+------+
| 20   |
+------+
1 row in set (0.00 sec)

--Note: you can also have INOUT parameters, which serve as both input and output
--parameters.



--OK, let's do some interesting stuff. First off, flow control:

DROP PROCEDURE IF EXISTS mySign //
CREATE PROCEDURE mySign(IN x INT)
BEGIN
  IF x > 0 THEN
    SELECT x AS Number, '+' AS Sign;
  ELSEIF x < 0 THEN
    SELECT x AS Number, '-' AS Sign;
  ELSE
    SELECT x AS Number, 'Zero' AS Sign;
  END IF;
END;
//

CALL mySign(2) //
CALL mySign(-5) //
CALL mySign(0) //

+--------+------+
| Number | Sign |
+--------+------+
|      2 | +    |
+--------+------+
1 row in set (0.00 sec)

+--------+------+
| Number | Sign |
+--------+------+
|     -5 | -    |
+--------+------+
1 row in set (0.00 sec)

+--------+------+
| Number | Sign |
+--------+------+
|      0 | Zero |
+--------+------+
1 row in set (0.00 sec)



--Before we get any further, let's introduce variables:

DROP PROCEDURE IF EXISTS mySign //
CREATE PROCEDURE mySign(IN x INT)
BEGIN

  DECLARE result VARCHAR(20);

  IF x > 0 THEN
    SET result = '+';
  ELSEIF x < 0 THEN
    SET result = '-';
  ELSE
    SET result = 'Zero';
  END IF;

  SELECT x AS Number, result AS Sign;

END;
//

CALL mySign(2) //
CALL mySign(-5) //
CALL mySign(0) //

+--------+------+
| Number | Sign |
+--------+------+
|      2 | +    |
+--------+------+
1 row in set (0.00 sec)

+--------+------+
| Number | Sign |
+--------+------+
|     -5 | -    |
+--------+------+
1 row in set (0.00 sec)

+--------+------+
| Number | Sign |
+--------+------+
|      0 | Zero |
+--------+------+
1 row in set (0.00 sec)



--Using CASE:

DROP PROCEDURE IF EXISTS digitName //
CREATE PROCEDURE digitName(IN x INT)
BEGIN

  DECLARE result VARCHAR(20);

  CASE x
    WHEN 0 THEN SET result = 'Zero';
    WHEN 1 THEN SET result = 'One';
    WHEN 2 THEN SET result = 'Two';
    WHEN 3 THEN SET result = 'Three';
    WHEN 4 THEN SET result = 'Four';
    WHEN 5 THEN SET result = 'Five';
    WHEN 6 THEN SET result = 'Six';
    WHEN 7 THEN SET result = 'Seven';
    WHEN 8 THEN SET result = 'Eight';
    WHEN 9 THEN SET result = 'Nine';
    ELSE SET result = 'Not a digit';
  END CASE;

  SELECT x AS Digit, result AS Name;

END;
//

CALL digitName(0) //
CALL digitName(4) //
CALL digitName(100) //

+-------+------+
| Digit | Name |
+-------+------+
|     0 | Zero |
+-------+------+
1 row in set (0.00 sec)

+-------+------+
| Digit | Name |
+-------+------+
|     4 | Four |
+-------+------+
1 row in set (0.00 sec)

+-------+-------------+
| Digit | Name        |
+-------+-------------+
|   100 | Not a digit |
+-------+-------------+
1 row in set (0.00 sec)



--As you'd expect, we have loops. For example, WHILE loops:

DROP PROCEDURE IF EXISTS fact //
CREATE PROCEDURE fact(IN x INT)
BEGIN

  DECLARE result INT;
  DECLARE i INT;
  SET result = 1;
  SET i = 1;

  WHILE i <= x DO
    SET result = result * i;
    SET i = i + 1;
  END WHILE;

  SELECT x AS Number, result as Factorial;

END;
//

CALL fact(1) //
CALL fact(2) //
CALL fact(4) //
CALL fact(0) //

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      1 |         1 |
+--------+-----------+
1 row in set (0.00 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      2 |         2 |
+--------+-----------+
1 row in set (0.00 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      4 |        24 |
+--------+-----------+
1 row in set (0.01 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      0 |         1 |
+--------+-----------+
1 row in set (0.00 sec)



--There is also REPEAT/UNTIL loops:

DROP PROCEDURE IF EXISTS fact //
CREATE PROCEDURE fact(IN x INT)
BEGIN

  DECLARE result INT DEFAULT 1;  /* notice you can declare a variable*/
  DECLARE i INT DEFAULT 1;       /* and give it a value in one line */

  REPEAT
    SET result = result * i;
    SET i = i + 1;
  UNTIL i > x
  END REPEAT;

  SELECT x AS Number, result as Factorial;

END;
//

CALL fact(1) //
CALL fact(2) //
CALL fact(4) //
CALL fact(0) //

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      1 |         1 |
+--------+-----------+
1 row in set (0.00 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      2 |         2 |
+--------+-----------+
1 row in set (0.00 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      4 |        24 |
+--------+-----------+
1 row in set (0.00 sec)

+--------+-----------+
| Number | Factorial |
+--------+-----------+
|      0 |         1 |
+--------+-----------+
1 row in set (0.00 sec)



--OK, do you remember this?
/*
CREATE PROCEDURE FindStudent(IN id INT)
  SELECT StuID, CONCAT(FName, ' ', LName) AS 'Student Name'
  FROM Student
  WHERE StuID = id;
//
*/

--What if we only want to extract the name without printing it out?
--Obviously, we need some OUT parameters. Still, how do you extract
--information into those OUT parameters?
--
--Answer: something called a CURSOR:

DROP PROCEDURE IF EXISTS FindName //
CREATE PROCEDURE FindName(IN id INT, OUT fn VARCHAR(20), OUT ln VARCHAR(20))
BEGIN
  DECLARE cur CURSOR FOR
    SELECT FName, LName
    FROM Student
    WHERE StuID = id;
  OPEN cur;
  FETCH cur INTO fn, ln;
  CLOSE cur;
END;
//

CALL FindName(1001,@f,@l) //

Query OK, 0 rows affected (0.00 sec)

--Remember that @f and @l are MySQL variables:

SELECT @f //
SELECT @l //

+-------+
| @f    |
+-------+
| Linda |
+-------+
1 row in set (0.00 sec)

+-------+
| @l    |
+-------+
| Smith |
+-------+
1 row in set (0.00 sec)



--What if we give an invalid student ID?

CALL FindName(0000,@f,@l) //

ERROR 1329 (02000): No data to FETCH

--MySQL complains, as expected. It would be nice to handle this more elegantly, however.
--We need an error HANDLER. Let's modify FindName:

DROP PROCEDURE IF EXISTS FindName //
CREATE PROCEDURE FindName(IN id INT, OUT fn VARCHAR(20), OUT ln VARCHAR(20))
BEGIN
  DECLARE cur CURSOR FOR
    SELECT FName, LName
    FROM Student
    WHERE StuID = id;

  DECLARE EXIT HANDLER FOR NOT FOUND
    SELECT 'Sorry; this ID was not found' AS 'Error Message';

  OPEN cur;
  FETCH cur INTO fn, ln;
  CLOSE cur;
END;
//

CALL FindName(0000,@f,@l) //

+------------------------------+
| Error Message                |
+------------------------------+
| Sorry; this ID was not found |
+------------------------------+
1 row in set (0.00 sec)



--Another use for handlers: multiple FETCH calls using a CONTINUE handler.
--
--In this case, we use a CONTINUE handler that, instead of exiting the procedure
--upon encountering a NOT FOUND error, simply sets a variable done = 1.
--
--Why would we do that? And how does that help us carry out multiple FETCH calls?
--
--Take a look at this procedure, which traverses all the entries of a table to
--find the maximum and minimum age:

DROP PROCEDURE IF EXISTS MaxMinAge //
CREATE PROCEDURE MaxMinAge(OUT maxAge INT, OUT minAge INT)
BEGIN
  DECLARE currAge,maxSoFar,minSoFar,done INT;

  DECLARE cur CURSOR FOR
    SELECT Age
    FROM Student;

  DECLARE CONTINUE HANDLER FOR NOT FOUND
    SET done = 1;

  SET maxSoFar = 0;
  SET minSoFar = 1000;
  SET done = 0;

  OPEN cur;
  WHILE done = 0 DO
    FETCH cur INTO currAge;
    IF currAge > maxSoFar THEN
      SET maxSoFar = currAge;
    END IF;
    IF currAge < minSoFar THEN
      SET minSoFar = currAge;
    END IF;
  END WHILE;

  CLOSE cur;

  SET maxAge = maxSoFar;
  SET minAge = minSoFar;
 
END;
//

CALL MaxMinAge(@max,@min) //

Query OK, 0 rows affected (0.00 sec)

SELECT @max //
SELECT @min //

+------+
| @max |
+------+
| 27   |
+------+
1 row in set (0.00 sec)

+------+
| @min |
+------+
| 16   |
+------+
1 row in set (0.00 sec)






--In summary, stored procedures in MySQL look like this:

DROP PROCEDURE IF EXISTS procName //
CREATE PROCEDURE procName(parameter list)
BEGIN
  /* variable declarations */
  /* CURSOR definitions */
  /* declaring handlers */

  /* procedure body...whatever you want it to do */

END;
//


--In more detail:

DROP PROCEDURE IF EXISTS procName //
CREATE PROCEDURE procName(IN/OUT/INOUT parName parType, ...)
BEGIN
  /* variable declarations */
  DECLARE varName,... varType;
      /* e.g. DECLARE myName VARCHAR(20); DECLARE x,y,z INT;      */

  DECLARE varName varType DEFAULT value;
      /* e.g. DECLARE x INT DEFAULT 0;      */

  /* CURSOR definitions */
  DECLARE curName CURSOR FOR
    SELECT ...

      /* e.g. DECLARE cur1 CURSOR FOR
                SELECT FName, LName
                FROM Student;      */


  /* declaring handlers */
  DECLARE EXIT/CONTINUE HANDLER FOR errorType/errorNumber
    ... action ...            

      /* e.g. DECLARE EXIT HANDLER FOR NOT FOUND
                SELECT 'Sorry; this ID was not found' AS 'Error Message';      */

      /* e.g. DECLARE CONTINUE HANDLER FOR NOT FOUND
                SET done = 1;      */


  /* procedure body...whatever you want it to do */

    /* IF statement */
    IF cond1 THEN
      action1
    ELSEIF cond2 THEN
      action2
    ELSEIF cond3 THEN
      action3
    ELSE
      elseaction
    END IF;

        /* e.g. IF x > 0 THEN
                  SET result = '+';
                ELSEIF x < 0 THEN
                  SET result = '-';
                ELSE
                  SET result = 'Zero';
                END IF;      */

    /* CASE statement */
    CASE varName
      WHEN val1 THEN action1
      WHEN val2 THEN action2
      ELSE elseaction
    END CASE;

        /* e.g. CASE position
                  WHEN 1 THEN SET result = 'Gold Medal';
                  WHEN 2 THEN SET result = 'Silver Medal';
                  WHEN 3 THEN SET result = 'Bronze Medal';
                  ELSE SET result = 'No Medal!';
                END CASE;      */

    /* WHILE loop */
    WHILE cond DO
      action1
      action2
      ...
    END WHILE

        /* e.g. WHILE i < 5 DO
                  SET result = result + i;
                  SET i = i + 1;
                END WHILE;      */

    /* REPEAT/UNTIL loop */

    REPEAT
      action1
      action2
      ...
    UNTIL cond
    END REPEAT;

        /* e.g. REPEAT
                  SET result = result + i;
                  SET i = i + 1;
                UNTIL i >= 5
                END REPEAT;      */



    /* using a CURSOR */
    OPEN curName;
    .
    .
    FETCH curName INTO var1, var2, ...;
    .
    .
    CLOSE curName;

        /* e.g. Assume cur1 has id's, first names, and last names
                let's find the name of the student whose StuID is x:

                OPEN cur1;

                SET found = 0;
                WHILE found = 0 DO

                  FETCH cur1 INTO nextID, nextFName, nextLName;

                  IF nextID = x THEN
                    SET result = CONCAT(nextFName, ' ', nextLName);
                    SET found = 1;
                  END IF;                    

                END WHILE;

                CLOSE cur1;      */


END;
//




















CASE 4: A Stored Function that Accept No Parameters
DELIMITER |
CREATE FUNCTION sample_fn_no_param ()
RETURNS INT
BEGIN
DECLARE count INT;
SELECT COUNT(*) INTO count FROM emp;
RETURN count;
END
|
DELIMITER ;


Execute and Verify Commands
select sample_fn_no_param ();



A FUNCTION is always returns a value using the return statement. A  PROCEDURE may return one or more values through parameters or may not return at all.
b. Functions are normally used for computations where as procedures are normally used for executing business logic.
c. A Function returns 1 value only. Procedure can return multiple values (max 1024).
d. Stored procedure returns always integer value by default zero. Whereas function returns type could be scalar or table or table values
e. Stored procedure is precompiled execution plan where as functions are not.
f. A function can call directly by SQL statement like select func_name from dual while procedure cannot.
g.Stored procedure has the security and reduces the network traffic and also we can call stored procedure in any no. of applications at a time.
h. A Function can be used in the SQL Queries while a procedure cannot be used in SQL queries .that cause a major 
difference b/w function and procedures.






CREATE FUNCTION hello (s CHAR(20))
RETURNS CHAR(50) DETERMINISTIC
     RETURN CONCAT('Hello, ',s,'!');
END



SELECT hello('world');




1. Deterministic functions :Deterministic functions always result in the same output every time they are called with a fixed set of input values and given the same condition of the database. For example, AVG() function always results the same result given the qualifications stated above.
2. Nondeterministic functions :Nondeterministic functions result in different output each time they are called with a fixed set of input values even if the database state that they access remains the same. For example, GETDATE() function, results the current date and time value, always a different value.
Non-deterministic means a value like Now() or Rand() determines results. Your query is deterministic.



    

DELIMITER //

CREATE FUNCTION CalcIncome ( starting_value INT )
RETURNS INT
BEGIN
   DECLARE income INT;
   SET income = 0;

   label1: WHILE income <= 3000 DO
     SET income = income + starting_value;
   END WHILE label1;

   RETURN income;
END; //

DELIMITER ;
You could then reference your new function as follows:

SELECT CalcIncome (1000);


Syntax:

ALTER TABLE table_name  
RENAME TO new_table_name;  
Example:

In this example, the table name cus_tbl is renamed as cus_table.

ALTER TABLE cus_tbl  
RENAME TO cus_table;





    
    

create table Atable (aid int primary key);
alter table atable add name varchar(20);
insert into atable values (1,'one');


create table Btable (bid int primary key);
alter table btable add name varchar(20);
insert into btable values (11,'eleven');



create table ctable (aid int,bid int,foreign key(aid) references atable(aid),foreign key(bid) references btable(bid));


insert into ctable values(1,11);

select a.aid "A",b.bid "B" from atable a,btable b, ctable c where b.bid=c.bid and c.aid = a.aid;

select a.name,b.name from atable a,btable b, ctable c where b.bid=c.bid and c.aid = a.aid;

















1] create table Atable (aid int primary key)
   insert into atable values (1);

2] create table Btable (bid int primary key);
   insert into btable values (11);

3] create table ctable (aid int,bid int,foreign key(aid) references atable(aid),foreign key(bid) references btable(bid));

4] insert into ctable values(1,11);


5] select a.aid "A",b.bid "B" from atable a,btable b, ctable c where b.bid=c.bid and c.aid = a.aid;


truncate ctable
truncate atable
truncate btable

alter table atable add name varchar(20);
alter table btable add name varchar(20);

insert into atable values (1,'one');
insert into btable values (11,'eleven');

insert into ctable values (1,11);
insert into ctable values (1,12);

select a.name,b.name from atable a,btable b, ctable c where b.bid=c.bid and c.aid = a.aid;








                        
                        
                        
                        


1] create database university;
2] use university;
3] create table students (s_id INT(10) NOT NULL AUTO_INCREMENT, s_firstname VARCHAR(30) NOT NULL, s_lastname VARCHAR(30) NOT NULL, s_email VARCHAR(40), PRIMARY KEY (s_id));

4] insert into students (s_firstname,s_lastname,s_email) values ('Shankar', 'Bhat', 'shankar@example.com');
5] insert into students (s_firstname,s_lastname,s_email) values ('Venkat', 'Rao', 'venkat@example.com');
6] insert into students (s_firstname,s_lastname,s_email) values ('Mohan', 'Nair', 'mohan@example.com');
7] insert into students (s_firstname,s_lastname,s_email) values ('Abhijeet', 'Patel', 'abhi@example.com');
8] select * from students;
9] select * from students where s_id='3';
10] create table students (s_firstname VARCHAR(30) NOT NULL, s_lastname VARCHAR(30) NOT NULL, s_email VARCHAR(40), s_phone BIGINT(10) NOT NULL, PRIMARY KEY (s_phone, s_firstname));

11] insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Shankar', 'Bhat', 'shankar@example.com', '7303075409');
12] insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Venkat', 'Rao', 'venkat@example.com', '7404076894');
13] insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Mohan', 'Nair', 'mohan@example.com', '7404076892');
14] insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Abhijeet', 'Patel', 'abhi@example.com', '7404076991');
15] insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Manoj', 'Nair', 'manoj@example.com', '7404076892');
16] select * from students;
17] select * from students where s_firstname='Mohan' AND s_phone='7404076892';
18] ERROR [ insert into students (s_firstname,s_lastname,s_email,s_phone) values ('Manoj', 'Pillai', 'manoj@example.com', '7404076892');]

19] ALTER TABLE students ADD PRIMARY KEY (s_id);
20] ALTER TABLE students ADD CONSTRAINT pk_students PRIMARY KEY (s_phone,s_firstname);

21] select * from students;
22] create table courses (c_id INT(10) NOT NULL AUTO_INCREMENT, c_name VARCHAR(30) NOT NULL, PRIMARY KEY (c_id));
23] insert into courses (c_name) values ('Computer Science');
24] insert into courses (c_name) values ('Economics');
25] insert into courses (c_name) values ('Arts');
26] insert into courses (c_name) values ('Chemistry');
27] insert into courses (c_name) values ('Astro Physics');
28] select * from courses;
29] create table enrollment (e_id INT(10) NOT NULL AUTO_INCREMENT, e_StudentID integer, e_CourseID integer, e_year YEAR, PRIMARY KEY (e_id), FOREIGN KEY (e_StudentID) REFERENCES students(s_id), FOREIGN KEY (e_CourseID) REFERENCES courses(c_id));

30] insert into enrollment (e_StudentID, e_CourseID, e_year) values (1, 3, 2016);
31] insert into enrollment (e_StudentID, e_CourseID, e_year) values (2, 4, 2016);
32] insert into enrollment (e_StudentID, e_CourseID, e_year) values (3, 2, 2016);
33] insert into enrollment (e_StudentID, e_CourseID, e_year) values (4, 1, 2016);
34] ERROR [insert into enrollment (e_StudentID, e_CourseID, e_year) values (5, 1, 2016);]
35] select * from enrollment;











select d.departmentid,d.departmentname,e.name from department d left join employee e on d.departmentid=e.deptid;



Syntax:

ALTER TABLE table_name  
CHANGE COLUMN old_name new_name   
column_definition  
[ FIRST | AFTER column_name ]  
Example:

In this example, we will change the column name "cus_surname" to "cus_title".

Use the following query to do this:

 ALTER TABLE  cus_tbl  
CHANGE COLUMN cus_surname cus_title  
varchar(20) NOT NULL; 



https://github.com/sbmadake/SQLassessment




Syntax:

ALTER TABLE table_name  
DROP COLUMN column_name;  
Let's take an example to drop the column name "cus_address" from the table "cus_tbl".

Use the following query to do this:

ALTER TABLE cus_tbl  
DROP COLUMN cus_address;







The MODIFY command is used to change the column definition of the table.

Syntax:

ALTER TABLE table_name  
MODIFY column_name column_definition  
[ FIRST | AFTER column_name ];  
Example:

In this example, we modify the column cus_surname to be a data type of varchar(50) and force the column to allow NULL values.

Use the following query to do this:

ALTER TABLE cus_tbl  
MODIFY cus_surname varchar(50) NULL; 







Syntax:

 ALTER TABLE table_name  
 ADD new_column_name column_definition  
 [ FIRST | AFTER column_name ],  
ADD new_column_name column_definition  
[ FIRST | AFTER column_name ],  
  ...  
;  
Example:

In this example, we add two new columns "cus_address", and cus_salary in the existing table "cus_tbl". cus_address is added after cus_surname column and cus_salary is added after cus_age column.

Use the following query to do this:

ALTER TABLE cus_tbl  
ADD cus_address varchar(100) NOT NULL  
AFTER cus_surname,  
ADD cus_salary int(100) NOT NULL  
AFTER cus_age ; 









Example:

In this example, we add a new column "cus_age" in the existing table "cus_tbl".

Use the following query to do this:

ALTER TABLE cus_tbl  
ADD cus_age varchar(40) NOT NULL; 









MySQL ALTER statement is used when you want to change the name of your table or any table field. It is also used to add or delete an existing column in a table.

The ALTER statement is always used with "ADD", "DROP" and "MODIFY" commands according to the situation.

1) ADD a column in the table
Syntax:

ALTER TABLE table_name  
ADD new_column_name column_definition  
[ FIRST | AFTER column_name ];  

Parameters
table_name: It specifies the name of the table that you want to modify.

new_column_name: It specifies the name of the new column that you want to add to the table.

column_definition: It specifies the data type and definition of the column (NULL or NOT NULL, etc).

FIRST | AFTER column_name: It is optional. It tells MySQL where in the table to create the column. If this parameter is not specified, the new column will be added to the end of the table.

    
    
    
    
    

Books- It contains information about the books belongs to the library
Column Name	Data Type	Description
Book_No	Number(6)	Book identification number
Book_Name		VarChar2(30)	Name of the book
Author_name	Varchar2(30)	Author of the book
Cost	Number(7,2)	Cost of the book
Category	Char(10)	Category like System , Fiction ,Database etc.
			

1)	Insert data in Book table as follows:

Book_No	Book Name	Author	Cost	Category
101	Let us C	Denis Ritchie	450	System
102	Oracle – Complete Ref	Loni	550	Database
103	Mastering SQL	Loni	250	Database
104	PL SQL-Ref	Scott Urman	750	Database




1] select all the records
2] select records whose cost between >=500 and <=700
3] Find record with book name staring with O letter
4] find records whose cost is < avg cost
5] create new table with same structure
4] create new table as copy of books
5] create new table with database as category
6] find record with max cost
7] find record with min cost
8] find name of the author who has  published more than one book










create table shirts (name varchar(30),size enum('xsmall','small','medium','large'));

insert into shirts values('POLO','small');

insert into shirts values('corcs','large');
insert into shirts values('JP','asdf');

create table member (Member_Id int(5) primary key,Member_Name varchar(20),Member_address varchar(10),Acc_Open_Date date,Membership_type enum('Lifetime','Annual','Half Yearly','Quarterly'),Fees_paid int(5),Max_Books_Allowed int(2),Penalty_Amount double)








Books- It contains information about the books belongs to the library
Column Name	Data Type	Description
Book_No	Number(6)	Book identification number
Book_Name		VarChar2(30)	Name of the book
Author_name	Varchar2(30)	Author of the book
Cost	Number(7,2)	Cost of the book
Category	Char(10)	Category like System , Fiction ,Database etc.
			

1)	Insert data in Book table as follows:

Book_No	Book Name	Author	Cost	Category
101	Let us C	Denis Ritchie	450	System
102	Oracle – Complete Ref	Loni	550	Database
103	Mastering SQL	Loni	250	Database
104	PL SQL-Ref	Scott Urman	750	Database




1] select all the records
2] select records whose cost between >=500 and <=700
3] Find record with book name staring with O letter
4] find records whose cost is < avg cost
5] create new table with same structure
4] create new table as copy of books
5] create new table with database as category
6] find record with max cost
7] find record with min cost
8]find name of the author who has  published more than one book










create table shirts (name varchar(30),size enum('xsmall','small','medium','large'));

insert into shirts values('POLO','small');

insert into shirts values('corcs','large');
insert into shirts values('JP','asdf');

create table member (Member_Id int(5) primary key,Member_Name varchar(20),Member_address varchar(10),Acc_Open_Date date,Membership_type enum('Lifetime','Annual','Half Yearly','Quarterly'),Fees_paid int(5),Max_Books_Allowed int(2),Penalty_Amount double)












Before we proceed to explain the MySQL database system, let us revise a few definitions related to the database.

Database − A database is a collection of tables, with related data.
Table − A table is a matrix with data. A table in a database looks like a simple spreadsheet.
Column − One column (data element) contains data of one and the same kind, for example the column postcode.
Row − A row (= tuple, entry or record) is a group of related data, for example the data of one subscription.
Redundancy − Storing data twice, redundantly to make the system faster.
Primary Key − A primary key is unique. A key value can not occur twice in one table. With a key, you can only find one row.
Foreign Key − A foreign key is the linking pin between two tables.
Compound Key − A compound key (composite key) is a key that consists of multiple columns, because one column is not sufficiently unique.
Index − An index in a database resembles an index at the back of a book.
Referential Integrity − Referential Integrity makes sure that a foreign key value always points to an existing row.



What is a Database?
A database is a separate application that stores a collection of data. Each database has one or more distinct APIs for creating, accessing, managing, searching and replicating the data it holds.

Other kinds of data stores can also be used, such as files on the file system or large hash tables in memory but data fetching and writing would not be so fast and easy with those type of systems.

Nowadays, we use relational database management systems (RDBMS) to store and manage huge volume of data. This is called relational database because all the data is stored into different tables and relations are established using primary keys or other keys known as Foreign Keys.







MySQL is a very popular, open source database.
Officially pronounced “my Ess Que Ell” (not my sequel).
Handles very large databases;  very fast performance.
Why are we using MySQL?
Free (much cheaper than Oracle!)
Each student can install MySQL locally.
Easy to use Shell for creating tables, querying tables, etc.
Easy to use with Java JDBC

MySQL is a relational database management system based on SQL – Structured Query Language. The application is used for a wide range of purposes, including data warehousing, e-commerce, and logging applications.

The most common use for mySQL however, is for the purpose of a web database. It can be used to store anything from a single record of information to an entire inventory of available products for an online store.
